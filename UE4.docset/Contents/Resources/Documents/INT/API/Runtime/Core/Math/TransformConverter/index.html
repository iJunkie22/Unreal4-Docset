<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
		"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">
<head>
<title>TransformConverter</title>
<link rel="stylesheet" type="text/css" href="./../../../../../../Include/CSS/udn_public.css">
<link rel="stylesheet" type="text/css" href="./../../../../../../Include/CSS/udn_public_nosidebar.css" />
<link rel="stylesheet" type="text/css" href="./../../../../../../Include/CSS/jquery-ui-1.10.3.custom.css">
<style type="text/css">
#jumplink
{
	visibility:hidden;
}
</style>
<Script src="./../../../../../../Include/Javascript/jquery-1.7.1.min.js" type="text/javascript"></Script>
<Script src="./../../../../../../Include/Javascript/jquery-ui-1.10.3.custom.min.js" type="text/javascript"></Script>
<Script src="./../../../../../../Include/Javascript/udn.js" type="text/javascript"></Script>
<Script src="./../../../../../../Include/Javascript/jquery.fancybox-1.3.4.pack.js" type="text/javascript"></Script>
<link rel="stylesheet" type="text/css" href="./../../../../../../Include/CSS/jquery.fancybox-1.3.4.css">

<link rel="icon" href="./../../../../../../Include/Images/favicon.ico" type="image/x-icon" />
<link rel="shortcut icon" href="./../../../../../../Include/Images/favicon.ico" type="image/x-icon" />

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="title" content="TransformConverter" />
<meta name="crumbs" content="%ROOT%, API, API\Runtime, API\Runtime\Core, API\Runtime\Core\Math" />
<meta name="description" content="Copyright 1998-2015 Epic Games, Inc. All Rights Reserved." />
<meta name="availability" content="Public" />


</head>
<body id="webbgThree">
    <!-- Google Tag Manager -->
    <noscript>
        <iframe src="//www.googletagmanager.com/ns.html?id=GTM-KWRD6D"
                height="0" width="0" style="display:none;visibility:hidden"></iframe>
    </noscript>
    <script>
        (function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
            j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
            '//www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-KWRD6D');</script>
    <!-- End Google Tag Manager -->
    
    <div id="webThree">
        
        <div id="contentContainer">
            <div id="pagedefault">
                <div id="pagecontainer">
                    <div id="pagenav">
                        <div style="clear:both;">
                            <!-- Start of crumbs links -->
                            <div class="crumbs">
    <div id="jumplink" onclick="$('#sidebar').toggle();">
        Jump To
    </div>
    <p> <strong><a id="content_link" href="../../../../index.html" >Unreal Engine API Reference</a></strong> &gt; <strong><a id="content_link" href="../../../index.html" >Runtime</a></strong> &gt; <strong><a id="content_link" href="../../index.html" >Core</a></strong> &gt; <strong><a id="content_link" href="../index.html" >Math</a></strong> &gt; <span id="crumbs_page_title">TransformConverter</span></p>
</div>
                            <!-- End of crumbs links -->
                        </div>
                    </div>
                    <div id="maincol">
                        <!-- Start of H1 -->
                        <h1 id="H1TitleId">TransformConverter</h1>
                        <!-- End of H1 -->
                        <!-- Start of Markdown converted page content -->
                        <div class="heading expanded" onclick="sectionOnClick(this, 'syntax');">
        <p>Syntax</p>
    </div>
<div id="syntax">
    <div class="simplecode_api">
	<p>template&lt;class TransformType&gt;<br />struct TransformConverter<br /></p>
</div>
</div><div class="heading expanded" onclick="sectionOnClick(this, 'description');">
        <p>Remarks</p>
    </div>
<div id="description">
    <p>Transform calculus.
</p><p>A Transform represents a frame of reference in a local (often orthonormal) coordinate system. Essentially a transform represents conversion from a local space A to another local space B. Thus, it's commonly written as T[AB]. Keeping this notation of spaces explicit allows transformation calculus to be very simple and easily checked using something akin to dimensional analysis:
</p><p>T[AB] &#42; T[BC] =&gt; T[AC] (aka, Concatenate(T[AB], T[BC]) T[AB]^-1 =&gt; T[BA] (aka, Inverse(T[AB])
</p><p>Concatenate is illegal if the LHS output space is not equivalent to the RHS input space:
</p><p>T[AB] &#42; T[BC] &lt; OK T[BA] &#42; T[BC] &lt; illegal; output space is A, input space is B.
</p><p>So, if you have a spatial hierarchy like so:                A</p><pre class="prettyprint"><code>/     \</code></pre><pre class="prettyprint"><code>        /
       H</code></pre><p>You can easily construct the math to move from, say, Space D to Space H using notation purely in terms of the forward transforms that define the hierarchy:
</p><p>T[DH] = T[DB] &#42; T[BA] &#42; T[CA]^-1 &#42; T[GC]^-1 &#42; T[HG]^-1
</p><p>From a code standpoint, this gives us a well-defined set of methods that can be called on anything that can be interpreted as a transform and let it work uniformly. Matrices, Quats, Vectors, Scalars, and other custom classes that are unambiguously defined as transformational spaces can be concatenated together with a well-defined meaning. Fundamental Operations 
</p><p>The fundamental components of the Transform library are a collection of non-member functions (and their overloads):
</p><ul><li><p>Concatenate(TransformA, TransformB)
</p></li><li><p>Inverse(Transform)
</p></li><li><p>TransformPoint(Transform, Point)
</p></li><li><p>TransformVector(Transform, Vector)
</p></li><li><p>TransformCast&lt;Result, Transform&gt;
</p></li></ul><p>These operations are NOT member functions to support existing classes in UE4 without modification, and to more easily support extending the supported types with other existing classes.
</p><p>Concatenate 
</p><p>Generalized transform concatenation. It exists to ensure that any two classes that can be thought of as transformational spaces (listed above, along with any user-defined classes), can be combined uniformly with well defined semantics. For example, given A &#42; B in UE4 means two different things if A and B are matrices or quaternions. Concatenate abstracts this notion into an explicit syntax for combining transforms instead of focusing on the mathematical notation.
</p><p>The result of a concatenate operation depends on the types concatenated, but are guaranteed to be another type that supports the fundamental operations. For instance, concatenating two translations results in another translation, but concatenating a rotation followed by a translation might result in a <a id="content_link" href="../FMatrix/index.html" >FMatrix</a>, or potentially another class that efficiently contains this transformation (like maybe a class that holds a scalar+quat+vector).
</p><p>Generally you should not have to worry about the return type. Just Concatenate and then use another fundamental operation to transform a position and/or vector through that space. When you need to store the result you can either use auto, assume the type, or use TransformCast (covered below) to ensure the type.
</p><p>In certain rare cases, the result of Concatenate may be ambiguous (<a id="content_link" href="../FRotator/index.html" >FRotator</a> or <a id="content_link" href="../FQuat/index.html" >FQuat</a>?). In such cases, there is a Concatenate template overload that allows you to explicitly specify the ResultType. This should rarely be necessary.
</p><p>Inverse 
</p><p>Generalized transform inversion. Takes a transform from space A to space B and returns a transform that goes from space B to space A. The output type is guaranteed to be the same.
</p><p>Transform[Point|Vector] 
</p><p>The primary reason to construct a transform from space A to B is to transform things from space A to space B. TransformPoint does this for points in space, and TransformVector does this for vectors (extents or normals) in space.
</p><p>There are 2D variants for efficiency. All functions assume a non-projective transform (ie, they don't perform a homogeneous divide). The output type is guaranteed to be the same as the input.
</p><p>TransformCast&lt;Result, Transform&gt; 
</p><p>The job of the TransformCast is to provide efficient conversion from one transform type to another, when possible. This is typically done to store the transform in a specific variable type after a sequence of Concatenate and Inverse calls.
</p><p>Not all transforms can be cast. For instance, a scale cannot be cast to a translation. Usually the output of a cast operation is a generalized transform type like <a id="content_link" href="../FTransform/index.html" >FTransform</a>, <a id="content_link" href="../FMatrix/index.html" >FMatrix</a>, etc.
</p><p>TransformCast supports efficient identity pass-through (Type A -&gt; Type A) so applying a cast in generic code is safe and fast (no copying). Implementing a custom type. 
</p><p>While UE4 supports a wide variety of transforms, there is sometimes need to support another custom transform type. The core code provides basic scaffolding and a set of recommended practices to make this as easy as possible. This allows most of the functionality to be provided via member functions in the new custom type, while still allowing existing types to be adapted via non-member functions if you choose to do it that way. However, you will need to understand a few of the underlying templatized helpers that make this possible:
</p><ul><li><p>TransformConverter&lt;T&gt;
</p></li><li><p>ConcatenateRules&lt;T1, T2&gt;
</p></li></ul><p>TransformConverter&lt;T&gt; 
</p><p>TransformConverter&lt;&gt; implements the meat of TransformCast. It does it's work through the templatized static member function Convert&lt;T2&gt;. By default this method uses a conversion ctor to construct a T from a T2. Therefore your class can either provide such conversion ctors or specialize TransformConverter&lt;T&gt;::Convert&lt;T2&gt; for each transform type you can cast to.
</p><p>This class is a template struct with a template member to effectively allow partial specialization of either parameter, which function templates do no support. We need to call this as an explicit template call, so non-template overloads are not an option. We also need this to support partial specialization for the NULL conversion.
</p><p>ConcatenateRules&lt;T1, T2&gt; 
</p><p>In general, the result of a Concatenate call cannot be predicted by the template code. For instance, what is the result of Concatenate(FQuat, FRotator)? What if there are more than one type that can contain the transform (like <a id="content_link" href="../FMatrix/index.html" >FMatrix</a> and <a id="content_link" href="../FTransform/index.html" >FTransform</a>)? Concatenate() generally relies on overloads (template or non-template) to do the work. However, requiring all combinations of all types to be overloaded would be quite tedious, and generally unnecessary. Therefore, Concatenate supports a general template form that first converts both parameters to the appropriate return type via TransformCast&lt;&gt;, then calls Concatentate on those: return Concatenate(TransformCast&lt;Result&gt;(LHS), TransformCast&lt;Result&gt;(RHS));
</p><p>This makes it convenient to automatically support flexible concatenation by leveraging the conversion mechanics of TransformCast&lt;&gt;.
</p><p>But how does one determine the "appropriate" return type? This is done via the ConcatenateRules&lt;T1, T2&gt; template, which simply defines the appropriate ResultType for Concatenate&lt;T1, T2&gt;: typedef XXX ResultType;
</p><p>The default implementation is empty, meaning there is no support available. There is a partial specialization for the same types so the code can always assume that Concatenate&lt;T,T&gt; -&gt; T.
</p><p>Remember that TransformCast&lt;T,T&gt; is a NOOP, so this works efficiently.
</p><p>It is up to the implementor of a custom class to define any additional <a id="content_link" href="../ConcatenateRules/index.html" >ConcatenateRules</a> for their new type.
</p><p>Also note that implementing every Concatenate by first upcasting each parameter to the result type may not be very efficient. In those cases, providing direct, non-template overload of Concatenate may be better. See the example below for details. Example Custom type 
</p><p>Say you wanted to create a type that only supports uniform scale followed by 3D translation. Let's call this type TranformST for shorthand.
</p><p>The core code provides default template implementations that pass through to member functions of the custom type. This allows most of the functionality to be centralized in the new custom type, while still allowing for non-member overloads if you choose to do it that way.
</p><p>The following class skeleton provides the basic signature of a class that supports the Transform Calculus:
</p><p>class FTransformST { public: explicit FTransformST(float InScale); // 1. Used by: <a id="content_link" href="index.html" >TransformConverter</a> explicit FTransformST(const FVector&amp; InTranslation); // 1. Used by: <a id="content_link" href="index.html" >TransformConverter</a><a id="content_link" href="../FMatrix/index.html" >FMatrix</a> ToMatrix() const; // 2. (OPTIONAL) Used by: <a id="content_link" href="../TransformConverter_FMatrix/index.html" >TransformConverter&lt;FMatrix&gt;</a><a id="content_link" href="../FVector/index.html" >FVector</a> TransformPoint(const FVector&amp; Point) const; // 3. Used by: TransformPoint <a id="content_link" href="../FVector/index.html" >FVector</a> TransformVector(const FVector&amp; Vector) const; // 4. Used by: TransformVector FTransformST Concatenate(const FTransformST&amp; RHS) const; // 5. Used by: Concatenate FTransformST Inverse() const; // 6. Used by: Inverse };
</p><p>inline FTransformST Concatenate(float LHS, const FVector&amp; RHS); // 7. (OPTIONAL) Used by: Concatenate inline FTransformST Concatenate(const FVector&amp; LHS, float RHS); // 7. (OPTIONAL) Used by: Concatenate
</p><p>template&lt;&gt; struct ConcatenateRules&lt;FTransformST, float       &gt; { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate template&lt;&gt; struct ConcatenateRules&lt;float       , FTransformST&gt; { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate template&lt;&gt; struct ConcatenateRules&lt;FTransformST, FVector     &gt; { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate template&lt;&gt; struct ConcatenateRules&lt;FVector     , FTransformST&gt; { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate
</p><p>template&lt;&gt; struct ConcatenateRules&lt;FTransformST, FMatrix     &gt; { typedef <a id="content_link" href="../FMatrix/index.html" >FMatrix</a> ResultType; }; // 9. (OPTIONAL) Used by: Concatenate template&lt;&gt; struct ConcatenateRules&lt;FMatrix     , FTransformST&gt; { typedef <a id="content_link" href="../FMatrix/index.html" >FMatrix</a> ResultType; }; // 9. (OPTIONAL) Used by: Concatenate
</p><p>Provide conversion constructors (can be explicit) to convert a lower level transform into this higher level one. In this case, we can convert any translation or scale to a FTransformST. This will be used by the Concatenate rules below to upcast any lower level types so they can be concatenated together.
</p><p>(OPTIONAL) Provide a ToMatrix function to allow this type to be concatenated with <a id="content_link" href="../FMatrix/index.html" >FMatrix</a> automatically (which is a common fundamental transform). There is a specialization of <a id="content_link" href="index.html" >TransformConverter</a> for <a id="content_link" href="../FMatrix/index.html" >FMatrix</a> that looks for this member function as a convenience to custom class providers.
</p><p>Provide a TransformPoint method (and perhaps a 2D version) which will be used by the default template implementation of TransformPoint. If you choose not to provide a member function, you can instead provide a non-template overload of TransformPoint(FTransformTS, FVector).
</p><p>Provide a TransformVector method (and perhaps a 2D version) which will be used by the default template implementation of TransformPoint. If you choose not to provide a member function, you can instead provide a non-template overload of TransformVector(FTransformTS, FVector).
</p><p>Provide a Concatenate method which will be used by the default template implementation of Concatenate. If you choose not to provide a member function, you can instead provide a non-template overload of Concatenate(FTransformTS, FTransformTS).
</p><p>Provide a Inverse method which will be used by the default template implementation of Inverse. If you choose not to provide a member function, you can instead provide a non-template overload of Inverse(FTransformTS).
</p><p>Provide some specializations of Concatenate that more efficiently represent the transforms your class supports. In this case, our class can represent an arbitrary combination of uniform scale and translation, so by providing explicit overloads, these more efficient versions will be used instead of promoting both types to FTransformST first.
</p><p>Since we don't provide explicit Concatenate combinations for all possibly types (we could), we provide some ConcatenateRules&lt;&gt; to allow the default Concatenate implementation to work with scalars and transform vectors.
</p><p>We also provide a set of <a id="content_link" href="../ConcatenateRules/index.html" >ConcatenateRules</a> for <a id="content_link" href="../FMatrix/index.html" >FMatrix</a>. This ends up using the ToMatrix member function we provided in 2.Provides default logic (used by TransformCast) to convert one transform type to another via a conversion ctor.</p>
</div><div class="syntax">
	<div class="heading expanded" onclick="sectionOnClick(this, 'specializations');">
        <p>Specializations</p>
    </div>
<div id="specializations">
    <p><a id="content_link" href="../TransformConverter_FMatrix/index.html" >TransformConverter&lt; FMatrix ></a>  </p>
</div><div class="heading expanded" onclick="sectionOnClick(this, 'functions_0');">
        <p>Functions</p>
    </div>
<div id="functions_0">
    <div class="member-list">
	<table cellspacing="0">
		<tr class="header-row">
			<th class="icon-cell" style="width:10%">
			</th>
			<th class="name-cell" style="width:8%;">
			</th>
			<th class="name-cell" style="width:15%;">
				Name
			</th>
			<th class="desc-cell">
				Description
			</th>
		</tr><tr class="normal-row">
	<td class="icon-cell">
		<p><img alt="Public function" title="Public function" width="18" src="./../../../../../../images/./api_function_public.png" />
<img alt="Static" title="Static" width="18" src="./../../../../../../images/./api_function_static.png" /></p>
	</td>
	<td class="name-cell" align="right">
		<span class="type-span"><p>const Transf...</p></span>&nbsp;
	</td>
	<td class="name-cell">
		<a href="Convert/1/index.html"><nobr><p>Convert</p></nobr></a>
		<div class="name-cell-arguments">
			<p>&#40;<br />&nbsp;&nbsp;&nbsp;&nbsp;const TransformType&amp; Transform<br />&#41;  </p>
		</div>
	</td>
	<td class="desc-cell">
		<p>Efficient NULL conversion.</p>
	</td>
</tr><tr class="normal-row">
	<td class="icon-cell">
		<p><img alt="Public function" title="Public function" width="18" src="./../../../../../../images/./api_function_public.png" />
<img alt="Static" title="Static" width="18" src="./../../../../../../images/./api_function_static.png" /></p>
	</td>
	<td class="name-cell" align="right">
		<span class="type-span"><p>TransformTyp...</p></span>&nbsp;
	</td>
	<td class="name-cell">
		<a href="Convert/2/index.html"><nobr><p>Convert</p></nobr></a>
		<div class="name-cell-arguments">
			<p>&#40;<br />&nbsp;&nbsp;&nbsp;&nbsp;const OtherTransformType&amp; Transfor...<br />&#41;  </p>
		</div>
	</td>
	<td class="desc-cell">
		<p>Default Conversion via a conversion ctor.</p>
	</td>
</tr><tr class="normal-row">
	<td class="icon-cell">
		<p><img alt="Public function" title="Public function" width="18" src="./../../../../../../images/./api_function_public.png" /></p>
	</td>
	<td class="name-cell" align="right">
		<span class="type-span"><p><a id="content_link" href="../FRotator/index.html" >FRotator</a></p></span>&nbsp;
	</td>
	<td class="name-cell">
		<a href="Convert/3/index.html"><nobr><p>Convert</p></nobr></a>
		<div class="name-cell-arguments">
			<p>&#40;<br />&nbsp;&nbsp;&nbsp;&nbsp;const <a id="content_link" href="../FMatrix/index.html" >FMatrix</a>&amp; Transform<br />&#41;  </p>
		</div>
	</td>
	<td class="desc-cell">
		<p>Specialization for converting a <a id="content_link" href="../FMatrix/index.html" >FMatrix</a> to an <a id="content_link" href="../FRotator/index.html" >FRotator</a>.</p>
	</td>
</tr><tr class="normal-row">
	<td class="icon-cell">
		<p><img alt="Public function" title="Public function" width="18" src="./../../../../../../images/./api_function_public.png" /></p>
	</td>
	<td class="name-cell" align="right">
		<span class="type-span"><p><a id="content_link" href="../FTransform2D/index.html" >FTransform2D</a></p></span>&nbsp;
	</td>
	<td class="name-cell">
		<a href="Convert/4/index.html"><nobr><p>Convert</p></nobr></a>
		<div class="name-cell-arguments">
			<p>&#40;<br />&nbsp;&nbsp;&nbsp;&nbsp;const <a id="content_link" href="../../../SlateCore/Rendering/FSlateLayoutTransform/index.html" >FSlateLayoutTransform</a>&amp; Trans...<br />&#41;  </p>
		</div>
	</td>
	<td class="desc-cell">
		<p><a id="content_link" href="../../../SlateCore/Rendering/FSlateLayoutTransform/index.html" >FSlateLayoutTransform</a> adapters.</p>
	</td>
</tr></table>
</div>
</div>
</div><div class="heading expanded" onclick="sectionOnClick(this, 'references');">
        <p>References</p>
    </div>
<div id="references">
    <div class="member-list">
	<table cellspacing="0"><tr class="normal-row">
	<td class="name-cell">
		<p>Module</p>
	</td>
	<td class="desc-cell">
		<p><a id="content_link" href="../../index.html" >Core</a></p>
	</td>
</tr><tr class="normal-row">
	<td class="name-cell">
		<p>Header</p>
	</td>
	<td class="desc-cell">
		<p>Runtime&#47;Core&#47;Public&#47;Math&#47;TransformCalculus.h</p>
	</td>
</tr></table>
</div>
</div>
                        <!-- End of Markdown converted page content -->
                        
                    </div>
                </div>
            </div>
            <div id="footer">
                <div style="BACKGROUND-COLOR: transparent; margin: 0; padding: 0; width: 100%;border-top:1px solid #000000;">
                    <div style="text-align: center; vertical-align: bottom; width: 100%;">
                        Copyright &copy; 2001-2015 <a href="http://www.epicgames.com" target="_top">Epic Games, Inc.</a> | <a href="./../../../../../../INT/DevelopmentRoles/BusinessAndLegal/TermsAndConditions/index.html" class="twikiLink">Terms and Conditions</a> | <a href="http://epicgames.com/privacynotice" target="_top">Privacy Notice</a>
                    </div>
                </div>
            </div>
        </div>
    </div></body>
</html>
